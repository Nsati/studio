
/**
 * Core Philosophy:
 * This ruleset enforces a security model with three distinct access levels:
 * 1. Private User Data: User-specific information, like profiles and bookings, is strictly
 *    confined to the authenticated owner of that data.
 * 2. Public Content: General application data, such as hotel and room listings, is
 *    publicly readable by anyone but can only be managed by administrators.
 * 3. Administrative Roles: A specific collection (`roles_admin`) is used to grant
 *    privileged access for managing public content across the application.
 *
 * Data Structure:
 * The data is organized into top-level collections for public content (`hotels`)
 * and user data (`users`). User-specific subcollections like `bookings` are nested
 * under the corresponding user document (`/users/{userId}/bookings/{bookingId}`),
 * creating a clear, ownership-based hierarchy.
 *
 * Key Security Decisions:
 * - Admin-Only Management: The `Hotel` and `Room` entities lack an 'ownerId'.
 *   Therefore, all write operations (create, update, delete) on the `/hotels`
 *   collection and its subcollections are restricted to users designated as
 *   administrators via the `/roles_admin` collection.
 * - No User Listing: To protect user privacy, listing documents in the top-level
 *   `/users` collection is explicitly disallowed.
 * - Path-Based Ownership: All data under `/users/{userId}` is secured by rules
 *   that verify the requesting user's UID matches the `{userId}` in the path.
 * - Denormalization for Authorization: To ensure fast and secure rules, documents
 *   like `Booking` and `Room` contain denormalized IDs (`userId`, `hotelId`).
 *   The rules validate these IDs against the document path on creation and enforce
 *   their immutability on update, ensuring relational integrity without costly `get` calls.
 * - Safe Defaults: Destructive operations (`update`, `delete`) always verify that
 *   a document exists before allowing the operation to proceed. User account

 *   deletion via the API is disabled by default.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the requesting user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document being accessed already exists in Firestore.
     * Crucial for protecting against writes on non-existent documents.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * A convenient combination of isOwner and isExistingDoc for update/delete rules.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Returns true if the user has an admin role document.
     * Admin status is granted by the existence of a document in the `roles_admin` collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Validates that the user ID within a document is correctly set on create.
     * Ensures data integrity by linking the document data to its path owner.
     */
    function hasCorrectUserIdOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Validates that the user ID within a document has not been changed on update.
     * Enforces the immutability of the ownership link.
     */
    function isUserIdImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    //-------------------------------------------------------------------------
    // User Data Rules
    //-------------------------------------------------------------------------

    /**
     * @description Manages user profile documents. A user can create and update their
     *              own profile, but cannot read others' profiles or delete their own.
     * @path        /users/{userId}
     * @allow       (create) A new user signs up: auth.uid = 'user_abc', path = '/users/user_abc'.
     * @deny        (get) A user tries to read another's profile: auth.uid = 'user_abc', path = '/users/user_xyz'.
     * @principle   Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if false;
    }

    /**
     * @description Secures user bookings. A user has full control over their own bookings
     *              but cannot access bookings belonging to other users.
     * @path        /users/{userId}/bookings/{bookingId}
     * @allow       (create) A user creates a booking for themselves: auth.uid = 'user_abc', path = '/users/user_abc/bookings/...'.
     * @deny        (list) A user tries to list another user's bookings: auth.uid = 'user_abc', path = '/users/user_xyz/bookings'.
     * @principle   Enforces document ownership for all operations within a user-specific subcollection.
     */
    match /users/{userId}/bookings/{bookingId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && hasCorrectUserIdOnCreate(userId);
      allow update: if isExistingOwner(userId) && isUserIdImmutable();
      allow delete: if isExistingOwner(userId);
    }

    //-------------------------------------------------------------------------
    // Public Content Rules (Admin Managed)
    //-------------------------------------------------------------------------

    /**
     * @description Manages hotel listings. Hotel data is public for everyone to read.
     *              However, only administrators can create, update, or delete hotel entries.
     * @path        /hotels/{hotelId}
     * @allow       (get) Any anonymous user reads a hotel's details.
     * @deny        (create) A regular authenticated user tries to add a new hotel.
     * @principle   Implements a "Public Read with Admin-Only Writes" pattern for site content.
     */
    match /hotels/{hotelId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();

      /**
       * @description Manages rooms within a hotel. Room data is public.
       *              Only administrators can manage room entries.
       * @path        /hotels/{hotelId}/rooms/{roomId}
       * @allow       (list) Any user lists the rooms for a given hotel.
       * @deny        (update) A non-admin user tries to change a room's price.
       * @principle   Extends the parent collection's "Public Read, Admin Write" model to a subcollection.
       */
      match /rooms/{roomId} {
        allow get: if true;
        allow list: if true;
        allow create: if isAdmin() && request.resource.data.hotelId == hotelId;
        allow update: if isAdmin() && isExistingDoc() && request.resource.data.hotelId == resource.data.hotelId;
        allow delete: if isAdmin() && isExistingDoc();
      }
    }

    //-------------------------------------------------------------------------
    // Administrative Roles
    //-------------------------------------------------------------------------

    /**
     * @description Manages admin role grants. The existence of a document in this collection
     *              makes a user an admin. Only existing admins can add or remove other admins.
     * @path        /roles_admin/{userId}
     * @allow       (get) if isAdmin();
     * @allow list: if isAdmin();
     * @allow create: if isAdmin();
     * @allow update: if isAdmin() && isExistingDoc();
     * @allow delete: if isAdmin() && isExistingDoc();
    }
  }
}
