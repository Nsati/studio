/**
 * This ruleset enforces a security model for the Uttarakhand Getaways application.
 *
 * Core Philosophy:
 * The security model is dual-pronged: it enforces strict user ownership for private data while allowing public, read-only access to shared content like hotel listings. A global admin role, managed through the `/roles_admin` collection, grants privileged write access to public data.
 *
 * Data Structure:
 * - /users/{userId}: Private user profile data, accessible only by the owner.
 * - /users/{userId}/bookings/{bookingId}: Private booking data, nested under the owning user for strict access control.
 * - /hotels/{hotelId}: Publicly readable hotel information. Writable only by admins.
 * - /hotels/{hotelId}/rooms/{roomId}: Publicly readable room information. Writable only by admins.
 * - /roles_admin/{userId}: A lookup collection. The existence of a document here grants a user admin privileges across the application.
 *
 * Key Security Decisions:
 * - User Privacy: Listing users from the top-level `/users` collection is explicitly forbidden to prevent user enumeration and protect privacy.
 * - Public Browsing: Hotel and room data is publicly readable to allow unauthenticated users to browse listings.
 * - Admin-Only Writes: All modifications to public data (hotels, rooms) and role assignments are restricted to users with the admin role.
 * - Default Secure: Any path or operation not explicitly defined is denied by default.
 *
 * Denormalization for Authorization:
 * The ruleset uses the existence of a document in `/roles_admin/{userId}` to check for administrator privileges. This avoids a costly `get()` call to a user's profile document on every check, leading to faster and more efficient rule execution.
 *
 * Structural Segregation:
 * User-specific, private data (like `/users/{userId}/bookings`) is stored in a separate data tree from public, shared data (`/hotels`). This clear separation simplifies security rules, prevents accidental data leakage, and improves query performance.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //----------------------------------------------------------------------
    // Helper Functions
    //----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the foundation of the user ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if a document exists before an update or delete operation.
     * Prevents operations on non-existent data.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * A composite check for update/delete operations on user-owned documents.
     * Ensures the user is the owner AND the document already exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Checks if the user has an admin role by verifying the existence
     * of their UID in the '/roles_admin' collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * A composite check for update/delete operations by admins.
     * Ensures the user is an admin AND the document already exists.
     */
    function isExistingAdmin() {
      return isAdmin() && isExistingDoc();
    }

    //----------------------------------------------------------------------
    // Validation Functions (Prototyping Mode: Authorization-critical fields only)
    //----------------------------------------------------------------------

    /**
     * Validates the User document on creation.
     * Ensures the document's internal 'id' field matches its path {userId}.
     */
    function isUserDataValidOnCreate(userId) {
      let data = request.resource.data;
      return data.id == userId &&
             data.displayName is string &&
             data.email is string &&
             data.role == 'user';
    }

    /**
     * Enforces immutability of the User document's 'id' field on update.
     * This prevents re-assigning ownership of a user profile.
     */
    function isUserDataValidOnUpdate() {
      return request.resource.data.id == resource.data.id &&
             request.resource.data.role == resource.data.role; // Role should not be changed by user
    }

    /**
     * Validates the Booking document on creation.
     * Ensures the document's internal 'userId' field matches its path {userId}.
     */
    function isBookingDataValidOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces immutability of the Booking document's 'userId' field on update.
     * This prevents re-assigning ownership of a booking.
     */
    function isBookingDataValidOnUpdate() {
      return request.resource.data.userId == resource.data.userId;
    }

    //----------------------------------------------------------------------
    // Collection Rules
    //----------------------------------------------------------------------

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own profile document.
     * @deny (get) A user trying to read another user's profile.
     * @deny (list) Any attempt to list all user profiles.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && isUserDataValidOnCreate(userId);
      allow update: if (isExistingOwner(userId) && isUserDataValidOnUpdate()) || isExistingAdmin();
      allow delete: if isExistingOwner(userId) || isExistingAdmin();

      /**
       * @description Manages a user's private booking records.
       * @path /users/{userId}/bookings/{bookingId}
       * @allow (create) An authenticated user creating a booking for themselves.
       * @allow (list) An authenticated user listing their own past and current bookings.
       * @deny (get) A user trying to view another user's booking details.
       * @principle Enforces strict document ownership within a user-specific subcollection.
       */
      match /bookings/{bookingId} {
        allow get: if isOwner(userId) || isAdmin();
        allow list: if isOwner(userId) || isAdmin();
        allow create: if isOwner(userId) && isBookingDataValidOnCreate(userId);
        allow update: if isExistingOwner(userId) && isBookingDataValidOnUpdate();
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Manages public hotel listings.
     * @path /hotels/{hotelId}
     * @allow (get) Any user, including unauthenticated ones, viewing a hotel's details.
     * @allow (list) Any user, including unauthenticated ones, browsing the list of hotels.
     * @deny (create) A regular user attempting to add a new hotel.
     * @principle Allows public read access but restricts writes to privileged admin users.
     */
    match /hotels/{hotelId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isExistingAdmin();
      allow delete: if isExistingAdmin();

      /**
       * @description Manages room information for a specific hotel.
       * @path /hotels/{hotelId}/rooms/{roomId}
       * @allow (get) Any user viewing the room types and prices for a hotel.
       * @deny (update) A regular user attempting to change room prices.
       * @principle Inherits the public read / admin write model from its parent collection.
       */
      match /rooms/{roomId} {
        allow get: if true;
        allow list: if true;
        allow create: if isAdmin();
        allow update: if isExistingAdmin();
        allow delete: if isExistingAdmin();
      }
    }

    /**
     * @description Manages the list of users with admin privileges.
     * @path /roles_admin/{userId}
     * @allow (create) An existing admin granting admin rights to another user.
     * @deny (get) A non-admin user checking if another user is an admin.
     * @deny (list) A non-admin user trying to get a list of all administrators.
     * @principle Secures administrative roles by restricting all access to existing admins.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isExistingAdmin();
      allow delete: if isExistingAdmin();
    }
  }
}

    